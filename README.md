第一条:用静态工厂方法替代构造类
静态工厂方法与构造器不同的第一大优势在于，它们有名称。-effectiveJava.staticMethodReplaceConstructor.ownName
静态工厂方法与构造器不同的第二大优势在于，不必在每次调用它们的时候都创建一个新对象-effectiveJava.staticMethodReplaceConstructor.dontCreateNewObject
静态工厂方法与构造器不同的第三大优势在子，它们可以返回原返回类型的任何子类型的对象-effectiveJava.staticMethodReplaceConstructor.returnSubtypeObject
静态工厂的第四大优势在于，所返回的对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值-effectiveJava.staticMethodReplaceConstructor.returnByParamChange
静态工厂的第五大优势在于，方法返回的对象所属的类，在编写包含该静态工厂方法的类时可以不存在(服务提供者框架)-effectiveJava.staticMethodReplaceConstructor.serviceProviderFramework

第2条：遇到多个构造器参数时要考虑使用构建器
重叠构造器模式-effectiveJava.manyConstructorUseStructure.telescopingConstructor
javaBeans模式-effectiveJava.manyConstructorUseStructure.javaBeansConstructor
建造者（Builder）模式-effectiveJava.manyConstructorUseStructure.builderMode

第3条：用私有构造器或者枚举类型强化Singleton属性
公有静态成员实现单例-effectiveJava.useConstructorOrEnumSingleton.field
公有景太方法实现单例-effectiveJava.useConstructorOrEnumSingleton.staticFactory
--可能存在的问题:通过反射或者序列化,造成创建对象不唯一
--反射:effectiveJava.useConstructorOrEnumSingleton.field.ReflectDemo
--序列化:effectiveJava.useConstructorOrEnumSingleton.field.SerializeDemo
---反射相关避免方法:effectiveJava.useConstructorOrEnumSingleton.staticFactory.ElvisExceptionDeal
---序列化相关避免方法:effectiveJava.useConstructorOrEnumSingleton.field.Elvis
枚举单例:effectiveJava.useConstructorOrEnumSingleton.enumType
使用枚举进行单例模式-cc.demo.enumSingleton.BankMessageHM

第4条：通过私有构造器强化不可实例化的能力
-effectiveJava.privateConstructorIntensify

第5条：优先考虑依赖注人来引用资源
-effectiveJava.dependencyInjection
一句话:本来我接受各种参数来构造一个对象，现在只接受一个参数——已经实例化的对象。
-三种注入方式-effectiveJava.dependencyInjection.threeMethod

第6条：避免创建不必要的对象
有些创建实例的成本很高,引入有限状态机(finite state machine)来重复使用相关对象-effectiveJava.avoidCreateObject.FiniteStateMachineDemo
要优先使用基类型而不是装箱基本类型，要当心无意识的自动装箱-effectiveJava.avoidCreateObject.autoBoxingDemo.Demo